
Primary Workflow
================

Mirror is built to support a desktop/laptop workflow where you want to run a command line compile/build process on a powerful/dedicated desktop, but still edit files remotely on a laptop.

This is fairly common (see "Comparison to Existing Options" section below), but Mirror goes further to assume you also want to use an IDE on the laptop (e.g. for code completion, navigation, etc.), and IDEs often need local access to the binary artifacts from the build process, e.g.:

* On your laptop, save `projectA/foo.java`
  * Mirror sends `foo.java` to the desktop
* On your desktop, the build system picks up the `projectA/foo.java` change and creates `projectA-snapshot.jar`
  * Mirror sends `projectA-snapshot.jar` back to the laptop
* On your laptop, the IDE can now use `projectA-snapshot.jar` for code completion/etc. when editing `projectB/bar.java`

Granted, the IDE will also do local compilation of `projectA/foo.java`, so ideally (and on projects I'd worked on previously to the environment I need mirror for) the IDE could use in-workspace references, where the IDE-compiled `projectA/foo.java` is already/immediately on the classpath for `projectB`.

However, for some larger/more complex projects and build tools, e.g. those with various pre-/post-compilation code generation steps (that are often only performed in the CLI build, and not the IDE build), the IDE just can't reproduce the esoteric build process to fully compile `projectA` on it's own, and so using CLI-provided `projectX-snapshot.jar` artifacts is the only way to do local cross-project imports.

And this scenario (local edits, remotely-built cross-project artifacts) is exactly what Mirror is built to address.

Goals
=====

* Real-time, two-way sync between a desktop development machine, and an editor-/IDE-only laptop
* Native file system events (e.g. inotify) fired when files are changed (otherwise IDEs require explicit refreshes/polling)

Non-Goals
=========

* Offline/disconnected support (e.g. general purpose distributed file system)
  * Other than very basic "bring back into sync" support
* Maintain Unix permissions/owner/group
* Support for multiple clients
* Support for huge files
  * The assumption is that most files are source code, and occassional binary artifacts
* Super-efficient diff/transmission logic like rsync
  * Instead we assume a generally fast network connection

Comparison to Existing Options
==============================

* rsync is not two-way, nor two-way
* unison is two-way, but not real-time
* lsyncd is only one-way, and doesn't handle the initial sync
* sshfs is too slow and doesn't support inotify

Setup
=====

Current (pre-release) instructions using master:

* Build the project
  * `gradle shadowJar`
* Copy to remote home directory
  * `scp build/libs/mirror-all.jar example.com:~/`
* Copy to your local homed directory (not really necessary)
  * `cp build/libs/mirror-all.jar ~/`
* Start the server-side
  * `java -Xmx1G -cp mirror-all.jar mirror.MirrorServer 10000`
* Start the client-side
  * `java -Xmx1G -cp mirror-all.jar mirror.MirrorClient example.com 10000 ./dir/ ./dir/`

This will sync the `$HOME/dir` directory on your two machines.

Eventually it would be nice to run just one command, e.g. on the client-side, and have it auto-detect/auto-start the server daemon, and even SCP over the jar if needed, but currently it's not that fancy.

Also, there are no config options for what to include/exclude, for now I've just hardcoded defaults that are appropriate to my work.

Todo
====

* Configuration
  * Right now include/exclude settings are hardcoded, should be configurable
  * Use command line parameters? Config file? Both?
* Handle watch event overflows by restarting session
* Handle network disconnections by restarting session 
  * Ideally would be as sexy as mosh--the client just waits patiently until server is available again
* Handle various IOExceptions will inevitably happen, probably by restarting session
* Really easy setup/install process, e.g.:
  * Currently you have to run `java -cp ...` and `java -cp ...` on both sides
  * Should the server-side be an always-running daemon? Same thing with the client-side?
  * Maybe you just run the client, and it self-boots a server-daemon by SSH'ing it's jar over?
* Include file hashes to avoid sending files with different modification times
  * See Digest for an experiment; it's not that slow
* Use file hashes to detect renames
* Support svn:ignore
  * Or else just suggest users use git-svn for all svn repos
  * Possibly by converting in-memory to .gitignore
* Support .git/info/exclude
* Should syncing .git be a good idea?

