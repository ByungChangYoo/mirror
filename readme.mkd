
Primary Workflow
================

Mirror is built to support a two-machine (e.g. desktop+laptop) development workflow where you want to run a command line compile/build process on a powerful/dedicated desktop, but still edit files remotely on a laptop.

This is fairly common (see "Comparison to Existing Options" section below), but what makes Mirror unique is that it is two-way: it simultaneously syncs both laptop-to-desktop as well as desktop-to-laptop, in real time. For my personal use case, this is to facilitate using an IDE on the laptop (e.g. for code completion, navigation, etc.), and IDEs often need local access to the binary artifacts (or build time-generated source code) from the desktop-hosted build process, e.g.:

* On your laptop, save `projectA/foo.java`
  * Mirror sends `foo.java` to the desktop
* On your desktop, the build system picks up the `projectA/foo.java` change and creates `projectA-snapshot.jar`
  * Mirror sends `projectA-snapshot.jar` back to the laptop
* On your laptop, the IDE can now use `projectA-snapshot.jar` for code completion/etc. when editing `projectB/bar.java`

Granted, the IDE will also do local compilation of `projectA/foo.java`, so ideally the IDE could use in-workspace references, where the IDE-compiled `projectA/foo.java` is already/immediately on the IDE classpath for `projectB`. If you can setup your projects this way (e.g. with [m2e](http://www.eclipse.org/m2e/) or [IvyDE](https://ant.apache.org/ivy/ivyde/)), that is generally preferable.

However, for larger/more complex projects, e.g. those with various pre-/post-compilation code generation steps (that are often only performed in the CLI build), the IDE just can't reproduce the build process closely enough to fully compile `projectA` on it's own, and so using CLI-provided `projectX-snapshot.jar` artifacts is the only way to do local cross-project imports.

This scenario (local edits + remotely-built cross-project artifacts) is what Mirror addresses.

Goals
=====

* Real-time, two-way sync between a desktop development machine, and an editor-/IDE-only laptop
* Native file system events (e.g. inotify) fired when files are changed (otherwise IDEs require explicit refreshes/polling)

Non-Goals
=========

* Unison-style/long-duration disconnected support
  * `mirror` will automatically re-connect (e.g. if you close your laptop and then go home) and restart syncing (inspired by mosh), but if files have changed on both sides while disconnected, then the last write wins
  * This hueristic is generally fine, it just means `mirror` is not meant for a use case of "make new changes on the desktop for a few days, make new changes on the laptop for a few days, and then run `mirror` once per week to intelligently merge your work". Use `git` or `unison` for that; `mirror` is for real-time syncing.
* Maintain Unix permissions/owner/group
  * Whatever Unix user runs the `mirror` commands will be the owner/group/etc. of the files
* Support for multiple clients
  * The server code technically supports this (e.g. you could have two laptops connect to your desktop), and it should work in theory (each client would just see each other's write as any other file system write), but handling this use case is not an explicit goal
* Support for huge files
  * The assumption is that most files are source code, and occassional binary artifacts that are generally in the below-100mb range
* Super-efficient diff/transmission logic like rsync
  * Instead we assume a generally fast network connection (as in "faster than a modem", i.e. mirror works fine over a VPN)
  * Basically, if a file changes, `mirror` retransmits the whole file instead of trying to diff only what changed

Comparison to Existing Options
==============================

I looked at several sync options before starting mirror, but didn't find anything that quite fit:

* rsync is not two-way, nor real-time
* unison is two-way, but not real-time
* lsyncd is real-time, but not two-way, and doesn't handle the initial sync
* sshfs is too slow and doesn't support inotify
* doppleganger (an internal tool) is real-time, but not two-way
  * It also generally assumes you can run the build tool (e.g. gradle) on both laptop and desktop, and for my setup I want to only run it on the desktop
  * Similarly, doppleganger does let you have a git working copy on both laptop/desktop, but so far mirror generally assumes you have a git copy on only one of the desktop or laptop (your choice) and then the other side is just a dumb copy. Which means git commands, like `git log`, `tig`, etc., will only work on whatever machine you have your git check on.

Setup
=====

Current (pre-release) instructions using master:

* Build the project's uberjar
  * `gradle shadowJar`
* Copy to remote home directory
  * `scp build/libs/mirror-all.jar your-desktop.com:~/`
  * `scp mirror your-desktop.com:~/`
* Copy to your local home directory
  * `cp build/libs/mirror-all.jar ~/`
  * `cp mirror ~/`
* Start the server-side from the desktop's home directory
  * `./mirror server -p 10000`
* Start the client-side from the laptop's home directory
  * `./mirror client -h example.com -p 10000 -l ./code/ -r ./code/`

This will sync the `$HOME/code` directory on your two machines.

Eventually it would be nice to run just one command, e.g. on the client-side have a single `mirror ...` invocation, and have it auto-detect/auto-start the server daemon, and even SCP over the jar if needed, but currently it's not that fancy.

Also, there are currently no user-available config options for what files to include/exclude (although everything in your `.gitignore` is respected automatically), as for now I've just hardcoded defaults that are appropriate to my work (e.g. even though `build/*` is in the `.gitignore`, I've whitelisted `*-SNAPSHOT.jar` files to always be synced) .

Note that if you have a lot of directories, you might have to increase the native file system limits, e.g.

* For Linux see [https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers](this wiki page)
  * `echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p`
* For Mac, see [https://facebook.github.io/watchman/docs/install.html#system-specific-preparation](the watchman docs)

Include/Exclude Patterns
========================

By default, mirror will respect `.gitignore` files.

However, sometimes you want to sync files that ignored (e.g. generated source code or binary artifacts for your IDE); you can do this with the `-i`/`--include` parameter, e.g.:

    ./mirror client -h desktop.com -l ./code/ -r ./code/ -i '*-SNAPSHOT.jar' -i 'build/codegen'

Similarly, you can also exclude artifacts (granted, these are usually also excluded by `.gitignore`):

    ./mirror client -h desktop.com -l ./code/ -r ./code/ -e build

Todo
====

* Configuration via a `.mirrorrc` file
* Handle watch event overflows by restarting session
  * **Done** but might need some tweaks
* Handle network disconnections by restarting session 
  * **Done** but might need some tweaks
* Handle various IOExceptions will inevitably happen, probably by restarting session
* Really easy setup/install process, e.g.:
  * Currently you have to run `mirror ...` and `mirror ...` on both sides
  * Should the server-side be an always-running daemon? Same thing with the client-side?
  * Maybe you just run the client, and it self-boots a server-daemon by SSH'ing it's jar over?
* Include file hashes to avoid sending files with different modification times
  * See Digest for an experiment; collecting digests not that slow, but currently needless syncs don't seem that frequent/expensive
* Use file hashes to detect renames
  * Right now renaming `~/code/project-a` to `project-b` will treat every file as a delete+create; that said, it's still pretty fast, so probably not worth being smarter
* Support `svn:ignore`
  * Or else just suggest users use git-svn for all svn repos
  * Possibly by converting in-memory to `.gitignore`-format using that
* Support `.git/info/exclude`
  * Not sure how often this is used
* Should syncing .git be a good idea? (then `git log`/etc. would work on both sides)
  * Probably not; especially cross-platforms/versions of git, things could break
* Integrate with [watchman](https://facebook.github.io/watchman/) (potentially more reliable)


